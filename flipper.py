import cv2 as cv
import numpy as np

#Функция для перевода 16-ричного формата цвета в RGB 
#аргументы: s - строка 16-ричного цвета
#возвращает: кортеж из трех чисел, обозначающих цвет RGB
def hex_to_rgb(s):
    s = s.lstrip("#")
    return tuple([int(s[i:i + 2], 16) for i in range(0, 5, 2)])

#Функция для преобразования цвета в представлении RGB в 16-ричный формат
#аргументы: rgb - кортеж из трех чисел, обозначающих цвет RGB
#возвращает: строку 16-ричного цвета
def rgb_to_hex(rgb):
    r, g, b = rgb
    return f"#{hex(r)[2:].rjust(2, '0')}" \
           f"{hex(g)[2:].rjust(2, '0')}" \
           f"{hex(b)[2:].rjust(2, '0')}"

#Функция для переворота изображения и замены цветов на указанные
#аргументы:
  #origImName - строка с названием исходного изображения вида "название.png"
  #finishedImName - строка с названием для сохранения обработанного изображения вида "название.png"
  #colors - набор именованных аргументов вида: старый цвет=новый цвет
def flip_buildings(origImName: str, finishedImName: str, **colors):
  
  #Используем функцию cv2 для преобразования изображения в массив numpy
  image = cv.imread(origImName)
  
  #Так как cv2 считывает изображения в формате BGR, то переводим его в RGB
  image = cv.cvtColor(image, cv.COLOR_BGR2RGB)
  
  #используем функцию numpy для создания двумерного массива нулевых элементов повторяющих форму исходного изображения
  #заполнять мы его будем значениями из исходного изображения, но в другом порядке
  #первым аргументом вызвана функция cv2, которая возвращает кортеж вида (количество точек по вертикали, по горизонтали, количество каналов(цветов изображения))
  #вторым аргументом указан размер переменных внутри двумерного массива. Так как у нас максимальное значение цвета 255, то 8 бит нам хватит с головой
  im = np.zeros(image.shape, dtype="uint8")
  
  
  
  #теперь основной рабочий цикл. Здесь мы вставляем строки в созданную выше нулевую матрицу, но переварачивая ее 
  #первый цикл для строк, а второй для точек в строке
  for i in range(0, image.shape[0]):
    for j in range(1, image.shape[1]):
      
      #создаем кортеж и присваиваем ему точку оригинального изображения получаем кортеж из трех значений, обозначающих цвет в RGB
      pix = tuple(image[i][j])

      #если цвет пикселя, который мы перевели из RGB в 16-ричный формат есть в словаре переданных в функцию цветов, то приравниваем точке цвет по ключу (цвету в 16-ричном формате)
      if rgb_to_hex(pix) in colors:
        pix = colors[rgb_to_hex(pix)]
      
      #непосредственно кладем точку на противоположную часть строки
      im[i][image.shape[1] - j] = pix
    
    
  
  #Для корректного сохранения нужно снова перевести в BGR
  im = cv.cvtColor(im, cv.COLOR_RGB2BGR)
  
  #Функция cv2 для сохранения изображения
  #аргументы:
    #1 - название файла вида "название.png"
    #2 - двумерный массив пикселей
  cv.imwrite(finishedImName, im)


colors = {
"#6b6eba": (238, 73, 158), #Тут цвет на единичку отличается от того, который должен быть в теории. Если поменять на "#6b6ebb", то все сработает. Это либо ВК пережал все изображения, либо ошибка в задании
"#4687a5": (185, 86, 190),
"#f1d1c2": (196, 240, 245),
"#ffca18": (255, 24, 109)
}

flip_buildings("A9Z4ryDnbtk.png", "23.png", **colors)
